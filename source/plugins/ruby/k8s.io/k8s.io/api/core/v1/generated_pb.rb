# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: k8s.io/api/core/v1/generated.proto

require 'google/protobuf'

require 'k8s.io/apimachinery/pkg/api/resource/generated_pb'
require 'k8s.io/apimachinery/pkg/apis/meta/v1/generated_pb'
require 'k8s.io/apimachinery/pkg/runtime/generated_pb'
require 'k8s.io/apimachinery/pkg/runtime/schema/generated_pb'
require 'k8s.io/apimachinery/pkg/util/intstr/generated_pb'
Google::Protobuf::DescriptorPool.generated_pool.build do
  add_message "k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource" do
    optional :volumeID, :string, 1
    optional :fsType, :string, 2
    optional :partition, :int32, 3
    optional :readOnly, :bool, 4
  end
  add_message "k8s.io.api.core.v1.Affinity" do
    optional :nodeAffinity, :message, 1, "k8s.io.api.core.v1.NodeAffinity"
    optional :podAffinity, :message, 2, "k8s.io.api.core.v1.PodAffinity"
    optional :podAntiAffinity, :message, 3, "k8s.io.api.core.v1.PodAntiAffinity"
  end
  add_message "k8s.io.api.core.v1.AttachedVolume" do
    optional :name, :string, 1
    optional :devicePath, :string, 2
  end
  add_message "k8s.io.api.core.v1.AvoidPods" do
    repeated :preferAvoidPods, :message, 1, "k8s.io.api.core.v1.PreferAvoidPodsEntry"
  end
  add_message "k8s.io.api.core.v1.AzureDiskVolumeSource" do
    optional :diskName, :string, 1
    optional :diskURI, :string, 2
    optional :cachingMode, :string, 3
    optional :fsType, :string, 4
    optional :readOnly, :bool, 5
    optional :kind, :string, 6
  end
  add_message "k8s.io.api.core.v1.AzureFilePersistentVolumeSource" do
    optional :secretName, :string, 1
    optional :shareName, :string, 2
    optional :readOnly, :bool, 3
    optional :secretNamespace, :string, 4
  end
  add_message "k8s.io.api.core.v1.AzureFileVolumeSource" do
    optional :secretName, :string, 1
    optional :shareName, :string, 2
    optional :readOnly, :bool, 3
  end
  add_message "k8s.io.api.core.v1.Binding" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :target, :message, 2, "k8s.io.api.core.v1.ObjectReference"
  end
  add_message "k8s.io.api.core.v1.CSIPersistentVolumeSource" do
    optional :driver, :string, 1
    optional :volumeHandle, :string, 2
    optional :readOnly, :bool, 3
    optional :fsType, :string, 4
    map :volumeAttributes, :string, :string, 5
    optional :controllerPublishSecretRef, :message, 6, "k8s.io.api.core.v1.SecretReference"
    optional :nodeStageSecretRef, :message, 7, "k8s.io.api.core.v1.SecretReference"
    optional :nodePublishSecretRef, :message, 8, "k8s.io.api.core.v1.SecretReference"
    optional :controllerExpandSecretRef, :message, 9, "k8s.io.api.core.v1.SecretReference"
  end
  add_message "k8s.io.api.core.v1.CSIVolumeSource" do
    optional :driver, :string, 1
    optional :readOnly, :bool, 2
    optional :fsType, :string, 3
    map :volumeAttributes, :string, :string, 4
    optional :nodePublishSecretRef, :message, 5, "k8s.io.api.core.v1.LocalObjectReference"
  end
  add_message "k8s.io.api.core.v1.Capabilities" do
    repeated :add, :string, 1
    repeated :drop, :string, 2
  end
  add_message "k8s.io.api.core.v1.CephFSPersistentVolumeSource" do
    repeated :monitors, :string, 1
    optional :path, :string, 2
    optional :user, :string, 3
    optional :secretFile, :string, 4
    optional :secretRef, :message, 5, "k8s.io.api.core.v1.SecretReference"
    optional :readOnly, :bool, 6
  end
  add_message "k8s.io.api.core.v1.CephFSVolumeSource" do
    repeated :monitors, :string, 1
    optional :path, :string, 2
    optional :user, :string, 3
    optional :secretFile, :string, 4
    optional :secretRef, :message, 5, "k8s.io.api.core.v1.LocalObjectReference"
    optional :readOnly, :bool, 6
  end
  add_message "k8s.io.api.core.v1.CinderPersistentVolumeSource" do
    optional :volumeID, :string, 1
    optional :fsType, :string, 2
    optional :readOnly, :bool, 3
    optional :secretRef, :message, 4, "k8s.io.api.core.v1.SecretReference"
  end
  add_message "k8s.io.api.core.v1.CinderVolumeSource" do
    optional :volumeID, :string, 1
    optional :fsType, :string, 2
    optional :readOnly, :bool, 3
    optional :secretRef, :message, 4, "k8s.io.api.core.v1.LocalObjectReference"
  end
  add_message "k8s.io.api.core.v1.ClientIPConfig" do
    optional :timeoutSeconds, :int32, 1
  end
  add_message "k8s.io.api.core.v1.ComponentCondition" do
    optional :type, :string, 1
    optional :status, :string, 2
    optional :message, :string, 3
    optional :error, :string, 4
  end
  add_message "k8s.io.api.core.v1.ComponentStatus" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    repeated :conditions, :message, 2, "k8s.io.api.core.v1.ComponentCondition"
  end
  add_message "k8s.io.api.core.v1.ComponentStatusList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.ComponentStatus"
  end
  add_message "k8s.io.api.core.v1.ConfigMap" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :immutable, :bool, 4
    map :data, :string, :string, 2
    map :binaryData, :string, :bytes, 3
  end
  add_message "k8s.io.api.core.v1.ConfigMapEnvSource" do
    optional :localObjectReference, :message, 1, "k8s.io.api.core.v1.LocalObjectReference"
    optional :optional, :bool, 2
  end
  add_message "k8s.io.api.core.v1.ConfigMapKeySelector" do
    optional :localObjectReference, :message, 1, "k8s.io.api.core.v1.LocalObjectReference"
    optional :key, :string, 2
    optional :optional, :bool, 3
  end
  add_message "k8s.io.api.core.v1.ConfigMapList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.ConfigMap"
  end
  add_message "k8s.io.api.core.v1.ConfigMapNodeConfigSource" do
    optional :namespace, :string, 1
    optional :name, :string, 2
    optional :uid, :string, 3
    optional :resourceVersion, :string, 4
    optional :kubeletConfigKey, :string, 5
  end
  add_message "k8s.io.api.core.v1.ConfigMapProjection" do
    optional :localObjectReference, :message, 1, "k8s.io.api.core.v1.LocalObjectReference"
    repeated :items, :message, 2, "k8s.io.api.core.v1.KeyToPath"
    optional :optional, :bool, 4
  end
  add_message "k8s.io.api.core.v1.ConfigMapVolumeSource" do
    optional :localObjectReference, :message, 1, "k8s.io.api.core.v1.LocalObjectReference"
    repeated :items, :message, 2, "k8s.io.api.core.v1.KeyToPath"
    optional :defaultMode, :int32, 3
    optional :optional, :bool, 4
  end
  add_message "k8s.io.api.core.v1.Container" do
    optional :name, :string, 1
    optional :image, :string, 2
    repeated :command, :string, 3
    repeated :args, :string, 4
    optional :workingDir, :string, 5
    repeated :ports, :message, 6, "k8s.io.api.core.v1.ContainerPort"
    repeated :envFrom, :message, 19, "k8s.io.api.core.v1.EnvFromSource"
    repeated :env, :message, 7, "k8s.io.api.core.v1.EnvVar"
    optional :resources, :message, 8, "k8s.io.api.core.v1.ResourceRequirements"
    repeated :volumeMounts, :message, 9, "k8s.io.api.core.v1.VolumeMount"
    repeated :volumeDevices, :message, 21, "k8s.io.api.core.v1.VolumeDevice"
    optional :livenessProbe, :message, 10, "k8s.io.api.core.v1.Probe"
    optional :readinessProbe, :message, 11, "k8s.io.api.core.v1.Probe"
    optional :startupProbe, :message, 22, "k8s.io.api.core.v1.Probe"
    optional :lifecycle, :message, 12, "k8s.io.api.core.v1.Lifecycle"
    optional :terminationMessagePath, :string, 13
    optional :terminationMessagePolicy, :string, 20
    optional :imagePullPolicy, :string, 14
    optional :securityContext, :message, 15, "k8s.io.api.core.v1.SecurityContext"
    optional :stdin, :bool, 16
    optional :stdinOnce, :bool, 17
    optional :tty, :bool, 18
  end
  add_message "k8s.io.api.core.v1.ContainerImage" do
    repeated :names, :string, 1
    optional :sizeBytes, :int64, 2
  end
  add_message "k8s.io.api.core.v1.ContainerPort" do
    optional :name, :string, 1
    optional :hostPort, :int32, 2
    optional :containerPort, :int32, 3
    optional :protocol, :string, 4
    optional :hostIP, :string, 5
  end
  add_message "k8s.io.api.core.v1.ContainerState" do
    optional :waiting, :message, 1, "k8s.io.api.core.v1.ContainerStateWaiting"
    optional :running, :message, 2, "k8s.io.api.core.v1.ContainerStateRunning"
    optional :terminated, :message, 3, "k8s.io.api.core.v1.ContainerStateTerminated"
  end
  add_message "k8s.io.api.core.v1.ContainerStateRunning" do
    optional :startedAt, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
  end
  add_message "k8s.io.api.core.v1.ContainerStateTerminated" do
    optional :exitCode, :int32, 1
    optional :signal, :int32, 2
    optional :reason, :string, 3
    optional :message, :string, 4
    optional :startedAt, :message, 5, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :finishedAt, :message, 6, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :containerID, :string, 7
  end
  add_message "k8s.io.api.core.v1.ContainerStateWaiting" do
    optional :reason, :string, 1
    optional :message, :string, 2
  end
  add_message "k8s.io.api.core.v1.ContainerStatus" do
    optional :name, :string, 1
    optional :state, :message, 2, "k8s.io.api.core.v1.ContainerState"
    optional :lastState, :message, 3, "k8s.io.api.core.v1.ContainerState"
    optional :ready, :bool, 4
    optional :restartCount, :int32, 5
    optional :image, :string, 6
    optional :imageID, :string, 7
    optional :containerID, :string, 8
    optional :started, :bool, 9
  end
  add_message "k8s.io.api.core.v1.DaemonEndpoint" do
    optional :Port, :int32, 1
  end
  add_message "k8s.io.api.core.v1.DownwardAPIProjection" do
    repeated :items, :message, 1, "k8s.io.api.core.v1.DownwardAPIVolumeFile"
  end
  add_message "k8s.io.api.core.v1.DownwardAPIVolumeFile" do
    optional :path, :string, 1
    optional :fieldRef, :message, 2, "k8s.io.api.core.v1.ObjectFieldSelector"
    optional :resourceFieldRef, :message, 3, "k8s.io.api.core.v1.ResourceFieldSelector"
    optional :mode, :int32, 4
  end
  add_message "k8s.io.api.core.v1.DownwardAPIVolumeSource" do
    repeated :items, :message, 1, "k8s.io.api.core.v1.DownwardAPIVolumeFile"
    optional :defaultMode, :int32, 2
  end
  add_message "k8s.io.api.core.v1.EmptyDirVolumeSource" do
    optional :medium, :string, 1
    optional :sizeLimit, :message, 2, "k8s.io.apimachinery.pkg.api.resource.Quantity"
  end
  add_message "k8s.io.api.core.v1.EndpointAddress" do
    optional :ip, :string, 1
    optional :hostname, :string, 3
    optional :nodeName, :string, 4
    optional :targetRef, :message, 2, "k8s.io.api.core.v1.ObjectReference"
  end
  add_message "k8s.io.api.core.v1.EndpointPort" do
    optional :name, :string, 1
    optional :port, :int32, 2
    optional :protocol, :string, 3
    optional :appProtocol, :string, 4
  end
  add_message "k8s.io.api.core.v1.EndpointSubset" do
    repeated :addresses, :message, 1, "k8s.io.api.core.v1.EndpointAddress"
    repeated :notReadyAddresses, :message, 2, "k8s.io.api.core.v1.EndpointAddress"
    repeated :ports, :message, 3, "k8s.io.api.core.v1.EndpointPort"
  end
  add_message "k8s.io.api.core.v1.Endpoints" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    repeated :subsets, :message, 2, "k8s.io.api.core.v1.EndpointSubset"
  end
  add_message "k8s.io.api.core.v1.EndpointsList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.Endpoints"
  end
  add_message "k8s.io.api.core.v1.EnvFromSource" do
    optional :prefix, :string, 1
    optional :configMapRef, :message, 2, "k8s.io.api.core.v1.ConfigMapEnvSource"
    optional :secretRef, :message, 3, "k8s.io.api.core.v1.SecretEnvSource"
  end
  add_message "k8s.io.api.core.v1.EnvVar" do
    optional :name, :string, 1
    optional :value, :string, 2
    optional :valueFrom, :message, 3, "k8s.io.api.core.v1.EnvVarSource"
  end
  add_message "k8s.io.api.core.v1.EnvVarSource" do
    optional :fieldRef, :message, 1, "k8s.io.api.core.v1.ObjectFieldSelector"
    optional :resourceFieldRef, :message, 2, "k8s.io.api.core.v1.ResourceFieldSelector"
    optional :configMapKeyRef, :message, 3, "k8s.io.api.core.v1.ConfigMapKeySelector"
    optional :secretKeyRef, :message, 4, "k8s.io.api.core.v1.SecretKeySelector"
  end
  add_message "k8s.io.api.core.v1.EphemeralContainer" do
    optional :ephemeralContainerCommon, :message, 1, "k8s.io.api.core.v1.EphemeralContainerCommon"
    optional :targetContainerName, :string, 2
  end
  add_message "k8s.io.api.core.v1.EphemeralContainerCommon" do
    optional :name, :string, 1
    optional :image, :string, 2
    repeated :command, :string, 3
    repeated :args, :string, 4
    optional :workingDir, :string, 5
    repeated :ports, :message, 6, "k8s.io.api.core.v1.ContainerPort"
    repeated :envFrom, :message, 19, "k8s.io.api.core.v1.EnvFromSource"
    repeated :env, :message, 7, "k8s.io.api.core.v1.EnvVar"
    optional :resources, :message, 8, "k8s.io.api.core.v1.ResourceRequirements"
    repeated :volumeMounts, :message, 9, "k8s.io.api.core.v1.VolumeMount"
    repeated :volumeDevices, :message, 21, "k8s.io.api.core.v1.VolumeDevice"
    optional :livenessProbe, :message, 10, "k8s.io.api.core.v1.Probe"
    optional :readinessProbe, :message, 11, "k8s.io.api.core.v1.Probe"
    optional :startupProbe, :message, 22, "k8s.io.api.core.v1.Probe"
    optional :lifecycle, :message, 12, "k8s.io.api.core.v1.Lifecycle"
    optional :terminationMessagePath, :string, 13
    optional :terminationMessagePolicy, :string, 20
    optional :imagePullPolicy, :string, 14
    optional :securityContext, :message, 15, "k8s.io.api.core.v1.SecurityContext"
    optional :stdin, :bool, 16
    optional :stdinOnce, :bool, 17
    optional :tty, :bool, 18
  end
  add_message "k8s.io.api.core.v1.EphemeralContainers" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    repeated :ephemeralContainers, :message, 2, "k8s.io.api.core.v1.EphemeralContainer"
  end
  add_message "k8s.io.api.core.v1.EphemeralVolumeSource" do
    optional :volumeClaimTemplate, :message, 1, "k8s.io.api.core.v1.PersistentVolumeClaimTemplate"
    optional :readOnly, :bool, 2
  end
  add_message "k8s.io.api.core.v1.Event" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :involvedObject, :message, 2, "k8s.io.api.core.v1.ObjectReference"
    optional :reason, :string, 3
    optional :message, :string, 4
    optional :source, :message, 5, "k8s.io.api.core.v1.EventSource"
    optional :firstTimestamp, :message, 6, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :lastTimestamp, :message, 7, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :count, :int32, 8
    optional :type, :string, 9
    optional :eventTime, :message, 10, "k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime"
    optional :series, :message, 11, "k8s.io.api.core.v1.EventSeries"
    optional :action, :string, 12
    optional :related, :message, 13, "k8s.io.api.core.v1.ObjectReference"
    optional :reportingComponent, :string, 14
    optional :reportingInstance, :string, 15
  end
  add_message "k8s.io.api.core.v1.EventList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.Event"
  end
  add_message "k8s.io.api.core.v1.EventSeries" do
    optional :count, :int32, 1
    optional :lastObservedTime, :message, 2, "k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime"
  end
  add_message "k8s.io.api.core.v1.EventSource" do
    optional :component, :string, 1
    optional :host, :string, 2
  end
  add_message "k8s.io.api.core.v1.ExecAction" do
    repeated :command, :string, 1
  end
  add_message "k8s.io.api.core.v1.FCVolumeSource" do
    repeated :targetWWNs, :string, 1
    optional :lun, :int32, 2
    optional :fsType, :string, 3
    optional :readOnly, :bool, 4
    repeated :wwids, :string, 5
  end
  add_message "k8s.io.api.core.v1.FlexPersistentVolumeSource" do
    optional :driver, :string, 1
    optional :fsType, :string, 2
    optional :secretRef, :message, 3, "k8s.io.api.core.v1.SecretReference"
    optional :readOnly, :bool, 4
    map :options, :string, :string, 5
  end
  add_message "k8s.io.api.core.v1.FlexVolumeSource" do
    optional :driver, :string, 1
    optional :fsType, :string, 2
    optional :secretRef, :message, 3, "k8s.io.api.core.v1.LocalObjectReference"
    optional :readOnly, :bool, 4
    map :options, :string, :string, 5
  end
  add_message "k8s.io.api.core.v1.FlockerVolumeSource" do
    optional :datasetName, :string, 1
    optional :datasetUUID, :string, 2
  end
  add_message "k8s.io.api.core.v1.GCEPersistentDiskVolumeSource" do
    optional :pdName, :string, 1
    optional :fsType, :string, 2
    optional :partition, :int32, 3
    optional :readOnly, :bool, 4
  end
  add_message "k8s.io.api.core.v1.GitRepoVolumeSource" do
    optional :repository, :string, 1
    optional :revision, :string, 2
    optional :directory, :string, 3
  end
  add_message "k8s.io.api.core.v1.GlusterfsPersistentVolumeSource" do
    optional :endpoints, :string, 1
    optional :path, :string, 2
    optional :readOnly, :bool, 3
    optional :endpointsNamespace, :string, 4
  end
  add_message "k8s.io.api.core.v1.GlusterfsVolumeSource" do
    optional :endpoints, :string, 1
    optional :path, :string, 2
    optional :readOnly, :bool, 3
  end
  add_message "k8s.io.api.core.v1.HTTPGetAction" do
    optional :path, :string, 1
    optional :port, :message, 2, "k8s.io.apimachinery.pkg.util.intstr.IntOrString"
    optional :host, :string, 3
    optional :scheme, :string, 4
    repeated :httpHeaders, :message, 5, "k8s.io.api.core.v1.HTTPHeader"
  end
  add_message "k8s.io.api.core.v1.HTTPHeader" do
    optional :name, :string, 1
    optional :value, :string, 2
  end
  add_message "k8s.io.api.core.v1.Handler" do
    optional :exec, :message, 1, "k8s.io.api.core.v1.ExecAction"
    optional :httpGet, :message, 2, "k8s.io.api.core.v1.HTTPGetAction"
    optional :tcpSocket, :message, 3, "k8s.io.api.core.v1.TCPSocketAction"
  end
  add_message "k8s.io.api.core.v1.HostAlias" do
    optional :ip, :string, 1
    repeated :hostnames, :string, 2
  end
  add_message "k8s.io.api.core.v1.HostPathVolumeSource" do
    optional :path, :string, 1
    optional :type, :string, 2
  end
  add_message "k8s.io.api.core.v1.ISCSIPersistentVolumeSource" do
    optional :targetPortal, :string, 1
    optional :iqn, :string, 2
    optional :lun, :int32, 3
    optional :iscsiInterface, :string, 4
    optional :fsType, :string, 5
    optional :readOnly, :bool, 6
    repeated :portals, :string, 7
    optional :chapAuthDiscovery, :bool, 8
    optional :chapAuthSession, :bool, 11
    optional :secretRef, :message, 10, "k8s.io.api.core.v1.SecretReference"
    optional :initiatorName, :string, 12
  end
  add_message "k8s.io.api.core.v1.ISCSIVolumeSource" do
    optional :targetPortal, :string, 1
    optional :iqn, :string, 2
    optional :lun, :int32, 3
    optional :iscsiInterface, :string, 4
    optional :fsType, :string, 5
    optional :readOnly, :bool, 6
    repeated :portals, :string, 7
    optional :chapAuthDiscovery, :bool, 8
    optional :chapAuthSession, :bool, 11
    optional :secretRef, :message, 10, "k8s.io.api.core.v1.LocalObjectReference"
    optional :initiatorName, :string, 12
  end
  add_message "k8s.io.api.core.v1.KeyToPath" do
    optional :key, :string, 1
    optional :path, :string, 2
    optional :mode, :int32, 3
  end
  add_message "k8s.io.api.core.v1.Lifecycle" do
    optional :postStart, :message, 1, "k8s.io.api.core.v1.Handler"
    optional :preStop, :message, 2, "k8s.io.api.core.v1.Handler"
  end
  add_message "k8s.io.api.core.v1.LimitRange" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.LimitRangeSpec"
  end
  add_message "k8s.io.api.core.v1.LimitRangeItem" do
    optional :type, :string, 1
    map :max, :string, :message, 2, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    map :min, :string, :message, 3, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    map :default, :string, :message, 4, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    map :defaultRequest, :string, :message, 5, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    map :maxLimitRequestRatio, :string, :message, 6, "k8s.io.apimachinery.pkg.api.resource.Quantity"
  end
  add_message "k8s.io.api.core.v1.LimitRangeList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.LimitRange"
  end
  add_message "k8s.io.api.core.v1.LimitRangeSpec" do
    repeated :limits, :message, 1, "k8s.io.api.core.v1.LimitRangeItem"
  end
  add_message "k8s.io.api.core.v1.List" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.apimachinery.pkg.runtime.RawExtension"
  end
  add_message "k8s.io.api.core.v1.LoadBalancerIngress" do
    optional :ip, :string, 1
    optional :hostname, :string, 2
    repeated :ports, :message, 4, "k8s.io.api.core.v1.PortStatus"
  end
  add_message "k8s.io.api.core.v1.LoadBalancerStatus" do
    repeated :ingress, :message, 1, "k8s.io.api.core.v1.LoadBalancerIngress"
  end
  add_message "k8s.io.api.core.v1.LocalObjectReference" do
    optional :name, :string, 1
  end
  add_message "k8s.io.api.core.v1.LocalVolumeSource" do
    optional :path, :string, 1
    optional :fsType, :string, 2
  end
  add_message "k8s.io.api.core.v1.NFSVolumeSource" do
    optional :server, :string, 1
    optional :path, :string, 2
    optional :readOnly, :bool, 3
  end
  add_message "k8s.io.api.core.v1.Namespace" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.NamespaceSpec"
    optional :status, :message, 3, "k8s.io.api.core.v1.NamespaceStatus"
  end
  add_message "k8s.io.api.core.v1.NamespaceCondition" do
    optional :type, :string, 1
    optional :status, :string, 2
    optional :lastTransitionTime, :message, 4, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :reason, :string, 5
    optional :message, :string, 6
  end
  add_message "k8s.io.api.core.v1.NamespaceList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.Namespace"
  end
  add_message "k8s.io.api.core.v1.NamespaceSpec" do
    repeated :finalizers, :string, 1
  end
  add_message "k8s.io.api.core.v1.NamespaceStatus" do
    optional :phase, :string, 1
    repeated :conditions, :message, 2, "k8s.io.api.core.v1.NamespaceCondition"
  end
  add_message "k8s.io.api.core.v1.Node" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.NodeSpec"
    optional :status, :message, 3, "k8s.io.api.core.v1.NodeStatus"
  end
  add_message "k8s.io.api.core.v1.NodeAddress" do
    optional :type, :string, 1
    optional :address, :string, 2
  end
  add_message "k8s.io.api.core.v1.NodeAffinity" do
    optional :requiredDuringSchedulingIgnoredDuringExecution, :message, 1, "k8s.io.api.core.v1.NodeSelector"
    repeated :preferredDuringSchedulingIgnoredDuringExecution, :message, 2, "k8s.io.api.core.v1.PreferredSchedulingTerm"
  end
  add_message "k8s.io.api.core.v1.NodeCondition" do
    optional :type, :string, 1
    optional :status, :string, 2
    optional :lastHeartbeatTime, :message, 3, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :lastTransitionTime, :message, 4, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :reason, :string, 5
    optional :message, :string, 6
  end
  add_message "k8s.io.api.core.v1.NodeConfigSource" do
    optional :configMap, :message, 2, "k8s.io.api.core.v1.ConfigMapNodeConfigSource"
  end
  add_message "k8s.io.api.core.v1.NodeConfigStatus" do
    optional :assigned, :message, 1, "k8s.io.api.core.v1.NodeConfigSource"
    optional :active, :message, 2, "k8s.io.api.core.v1.NodeConfigSource"
    optional :lastKnownGood, :message, 3, "k8s.io.api.core.v1.NodeConfigSource"
    optional :error, :string, 4
  end
  add_message "k8s.io.api.core.v1.NodeDaemonEndpoints" do
    optional :kubeletEndpoint, :message, 1, "k8s.io.api.core.v1.DaemonEndpoint"
  end
  add_message "k8s.io.api.core.v1.NodeList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.Node"
  end
  add_message "k8s.io.api.core.v1.NodeProxyOptions" do
    optional :path, :string, 1
  end
  add_message "k8s.io.api.core.v1.NodeResources" do
    map :capacity, :string, :message, 1, "k8s.io.apimachinery.pkg.api.resource.Quantity"
  end
  add_message "k8s.io.api.core.v1.NodeSelector" do
    repeated :nodeSelectorTerms, :message, 1, "k8s.io.api.core.v1.NodeSelectorTerm"
  end
  add_message "k8s.io.api.core.v1.NodeSelectorRequirement" do
    optional :key, :string, 1
    optional :operator, :string, 2
    repeated :values, :string, 3
  end
  add_message "k8s.io.api.core.v1.NodeSelectorTerm" do
    repeated :matchExpressions, :message, 1, "k8s.io.api.core.v1.NodeSelectorRequirement"
    repeated :matchFields, :message, 2, "k8s.io.api.core.v1.NodeSelectorRequirement"
  end
  add_message "k8s.io.api.core.v1.NodeSpec" do
    optional :podCIDR, :string, 1
    repeated :podCIDRs, :string, 7
    optional :providerID, :string, 3
    optional :unschedulable, :bool, 4
    repeated :taints, :message, 5, "k8s.io.api.core.v1.Taint"
    optional :configSource, :message, 6, "k8s.io.api.core.v1.NodeConfigSource"
    optional :externalID, :string, 2
  end
  add_message "k8s.io.api.core.v1.NodeStatus" do
    map :capacity, :string, :message, 1, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    map :allocatable, :string, :message, 2, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    optional :phase, :string, 3
    repeated :conditions, :message, 4, "k8s.io.api.core.v1.NodeCondition"
    repeated :addresses, :message, 5, "k8s.io.api.core.v1.NodeAddress"
    optional :daemonEndpoints, :message, 6, "k8s.io.api.core.v1.NodeDaemonEndpoints"
    optional :nodeInfo, :message, 7, "k8s.io.api.core.v1.NodeSystemInfo"
    repeated :images, :message, 8, "k8s.io.api.core.v1.ContainerImage"
    repeated :volumesInUse, :string, 9
    repeated :volumesAttached, :message, 10, "k8s.io.api.core.v1.AttachedVolume"
    optional :config, :message, 11, "k8s.io.api.core.v1.NodeConfigStatus"
  end
  add_message "k8s.io.api.core.v1.NodeSystemInfo" do
    optional :machineID, :string, 1
    optional :systemUUID, :string, 2
    optional :bootID, :string, 3
    optional :kernelVersion, :string, 4
    optional :osImage, :string, 5
    optional :containerRuntimeVersion, :string, 6
    optional :kubeletVersion, :string, 7
    optional :kubeProxyVersion, :string, 8
    optional :operatingSystem, :string, 9
    optional :architecture, :string, 10
  end
  add_message "k8s.io.api.core.v1.ObjectFieldSelector" do
    optional :apiVersion, :string, 1
    optional :fieldPath, :string, 2
  end
  add_message "k8s.io.api.core.v1.ObjectReference" do
    optional :kind, :string, 1
    optional :namespace, :string, 2
    optional :name, :string, 3
    optional :uid, :string, 4
    optional :apiVersion, :string, 5
    optional :resourceVersion, :string, 6
    optional :fieldPath, :string, 7
  end
  add_message "k8s.io.api.core.v1.PersistentVolume" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.PersistentVolumeSpec"
    optional :status, :message, 3, "k8s.io.api.core.v1.PersistentVolumeStatus"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeClaim" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.PersistentVolumeClaimSpec"
    optional :status, :message, 3, "k8s.io.api.core.v1.PersistentVolumeClaimStatus"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeClaimCondition" do
    optional :type, :string, 1
    optional :status, :string, 2
    optional :lastProbeTime, :message, 3, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :lastTransitionTime, :message, 4, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :reason, :string, 5
    optional :message, :string, 6
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeClaimList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.PersistentVolumeClaim"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeClaimSpec" do
    repeated :accessModes, :string, 1
    optional :selector, :message, 4, "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
    optional :resources, :message, 2, "k8s.io.api.core.v1.ResourceRequirements"
    optional :volumeName, :string, 3
    optional :storageClassName, :string, 5
    optional :volumeMode, :string, 6
    optional :dataSource, :message, 7, "k8s.io.api.core.v1.TypedLocalObjectReference"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeClaimStatus" do
    optional :phase, :string, 1
    repeated :accessModes, :string, 2
    map :capacity, :string, :message, 3, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    repeated :conditions, :message, 4, "k8s.io.api.core.v1.PersistentVolumeClaimCondition"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeClaimTemplate" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.PersistentVolumeClaimSpec"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource" do
    optional :claimName, :string, 1
    optional :readOnly, :bool, 2
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.PersistentVolume"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeSource" do
    optional :gcePersistentDisk, :message, 1, "k8s.io.api.core.v1.GCEPersistentDiskVolumeSource"
    optional :awsElasticBlockStore, :message, 2, "k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource"
    optional :hostPath, :message, 3, "k8s.io.api.core.v1.HostPathVolumeSource"
    optional :glusterfs, :message, 4, "k8s.io.api.core.v1.GlusterfsPersistentVolumeSource"
    optional :nfs, :message, 5, "k8s.io.api.core.v1.NFSVolumeSource"
    optional :rbd, :message, 6, "k8s.io.api.core.v1.RBDPersistentVolumeSource"
    optional :iscsi, :message, 7, "k8s.io.api.core.v1.ISCSIPersistentVolumeSource"
    optional :cinder, :message, 8, "k8s.io.api.core.v1.CinderPersistentVolumeSource"
    optional :cephfs, :message, 9, "k8s.io.api.core.v1.CephFSPersistentVolumeSource"
    optional :fc, :message, 10, "k8s.io.api.core.v1.FCVolumeSource"
    optional :flocker, :message, 11, "k8s.io.api.core.v1.FlockerVolumeSource"
    optional :flexVolume, :message, 12, "k8s.io.api.core.v1.FlexPersistentVolumeSource"
    optional :azureFile, :message, 13, "k8s.io.api.core.v1.AzureFilePersistentVolumeSource"
    optional :vsphereVolume, :message, 14, "k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource"
    optional :quobyte, :message, 15, "k8s.io.api.core.v1.QuobyteVolumeSource"
    optional :azureDisk, :message, 16, "k8s.io.api.core.v1.AzureDiskVolumeSource"
    optional :photonPersistentDisk, :message, 17, "k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource"
    optional :portworxVolume, :message, 18, "k8s.io.api.core.v1.PortworxVolumeSource"
    optional :scaleIO, :message, 19, "k8s.io.api.core.v1.ScaleIOPersistentVolumeSource"
    optional :local, :message, 20, "k8s.io.api.core.v1.LocalVolumeSource"
    optional :storageos, :message, 21, "k8s.io.api.core.v1.StorageOSPersistentVolumeSource"
    optional :csi, :message, 22, "k8s.io.api.core.v1.CSIPersistentVolumeSource"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeSpec" do
    map :capacity, :string, :message, 1, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    optional :persistentVolumeSource, :message, 2, "k8s.io.api.core.v1.PersistentVolumeSource"
    repeated :accessModes, :string, 3
    optional :claimRef, :message, 4, "k8s.io.api.core.v1.ObjectReference"
    optional :persistentVolumeReclaimPolicy, :string, 5
    optional :storageClassName, :string, 6
    repeated :mountOptions, :string, 7
    optional :volumeMode, :string, 8
    optional :nodeAffinity, :message, 9, "k8s.io.api.core.v1.VolumeNodeAffinity"
  end
  add_message "k8s.io.api.core.v1.PersistentVolumeStatus" do
    optional :phase, :string, 1
    optional :message, :string, 2
    optional :reason, :string, 3
  end
  add_message "k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource" do
    optional :pdID, :string, 1
    optional :fsType, :string, 2
  end
  add_message "k8s.io.api.core.v1.Pod" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.PodSpec"
    optional :status, :message, 3, "k8s.io.api.core.v1.PodStatus"
  end
  add_message "k8s.io.api.core.v1.PodAffinity" do
    repeated :requiredDuringSchedulingIgnoredDuringExecution, :message, 1, "k8s.io.api.core.v1.PodAffinityTerm"
    repeated :preferredDuringSchedulingIgnoredDuringExecution, :message, 2, "k8s.io.api.core.v1.WeightedPodAffinityTerm"
  end
  add_message "k8s.io.api.core.v1.PodAffinityTerm" do
    optional :labelSelector, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
    repeated :namespaces, :string, 2
    optional :topologyKey, :string, 3
  end
  add_message "k8s.io.api.core.v1.PodAntiAffinity" do
    repeated :requiredDuringSchedulingIgnoredDuringExecution, :message, 1, "k8s.io.api.core.v1.PodAffinityTerm"
    repeated :preferredDuringSchedulingIgnoredDuringExecution, :message, 2, "k8s.io.api.core.v1.WeightedPodAffinityTerm"
  end
  add_message "k8s.io.api.core.v1.PodAttachOptions" do
    optional :stdin, :bool, 1
    optional :stdout, :bool, 2
    optional :stderr, :bool, 3
    optional :tty, :bool, 4
    optional :container, :string, 5
  end
  add_message "k8s.io.api.core.v1.PodCondition" do
    optional :type, :string, 1
    optional :status, :string, 2
    optional :lastProbeTime, :message, 3, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :lastTransitionTime, :message, 4, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :reason, :string, 5
    optional :message, :string, 6
  end
  add_message "k8s.io.api.core.v1.PodDNSConfig" do
    repeated :nameservers, :string, 1
    repeated :searches, :string, 2
    repeated :options, :message, 3, "k8s.io.api.core.v1.PodDNSConfigOption"
  end
  add_message "k8s.io.api.core.v1.PodDNSConfigOption" do
    optional :name, :string, 1
    optional :value, :string, 2
  end
  add_message "k8s.io.api.core.v1.PodExecOptions" do
    optional :stdin, :bool, 1
    optional :stdout, :bool, 2
    optional :stderr, :bool, 3
    optional :tty, :bool, 4
    optional :container, :string, 5
    repeated :command, :string, 6
  end
  add_message "k8s.io.api.core.v1.PodIP" do
    optional :ip, :string, 1
  end
  add_message "k8s.io.api.core.v1.PodList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.Pod"
  end
  add_message "k8s.io.api.core.v1.PodLogOptions" do
    optional :container, :string, 1
    optional :follow, :bool, 2
    optional :previous, :bool, 3
    optional :sinceSeconds, :int64, 4
    optional :sinceTime, :message, 5, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :timestamps, :bool, 6
    optional :tailLines, :int64, 7
    optional :limitBytes, :int64, 8
    optional :insecureSkipTLSVerifyBackend, :bool, 9
  end
  add_message "k8s.io.api.core.v1.PodPortForwardOptions" do
    repeated :ports, :int32, 1
  end
  add_message "k8s.io.api.core.v1.PodProxyOptions" do
    optional :path, :string, 1
  end
  add_message "k8s.io.api.core.v1.PodReadinessGate" do
    optional :conditionType, :string, 1
  end
  add_message "k8s.io.api.core.v1.PodSecurityContext" do
    optional :seLinuxOptions, :message, 1, "k8s.io.api.core.v1.SELinuxOptions"
    optional :windowsOptions, :message, 8, "k8s.io.api.core.v1.WindowsSecurityContextOptions"
    optional :runAsUser, :int64, 2
    optional :runAsGroup, :int64, 6
    optional :runAsNonRoot, :bool, 3
    repeated :supplementalGroups, :int64, 4
    optional :fsGroup, :int64, 5
    repeated :sysctls, :message, 7, "k8s.io.api.core.v1.Sysctl"
    optional :fsGroupChangePolicy, :string, 9
    optional :seccompProfile, :message, 10, "k8s.io.api.core.v1.SeccompProfile"
  end
  add_message "k8s.io.api.core.v1.PodSignature" do
    optional :podController, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference"
  end
  add_message "k8s.io.api.core.v1.PodSpec" do
    repeated :volumes, :message, 1, "k8s.io.api.core.v1.Volume"
    repeated :initContainers, :message, 20, "k8s.io.api.core.v1.Container"
    repeated :containers, :message, 2, "k8s.io.api.core.v1.Container"
    repeated :ephemeralContainers, :message, 34, "k8s.io.api.core.v1.EphemeralContainer"
    optional :restartPolicy, :string, 3
    optional :terminationGracePeriodSeconds, :int64, 4
    optional :activeDeadlineSeconds, :int64, 5
    optional :dnsPolicy, :string, 6
    map :nodeSelector, :string, :string, 7
    optional :serviceAccountName, :string, 8
    optional :serviceAccount, :string, 9
    optional :automountServiceAccountToken, :bool, 21
    optional :nodeName, :string, 10
    optional :hostNetwork, :bool, 11
    optional :hostPID, :bool, 12
    optional :hostIPC, :bool, 13
    optional :shareProcessNamespace, :bool, 27
    optional :securityContext, :message, 14, "k8s.io.api.core.v1.PodSecurityContext"
    repeated :imagePullSecrets, :message, 15, "k8s.io.api.core.v1.LocalObjectReference"
    optional :hostname, :string, 16
    optional :subdomain, :string, 17
    optional :affinity, :message, 18, "k8s.io.api.core.v1.Affinity"
    optional :schedulerName, :string, 19
    repeated :tolerations, :message, 22, "k8s.io.api.core.v1.Toleration"
    repeated :hostAliases, :message, 23, "k8s.io.api.core.v1.HostAlias"
    optional :priorityClassName, :string, 24
    optional :priority, :int32, 25
    optional :dnsConfig, :message, 26, "k8s.io.api.core.v1.PodDNSConfig"
    repeated :readinessGates, :message, 28, "k8s.io.api.core.v1.PodReadinessGate"
    optional :runtimeClassName, :string, 29
    optional :enableServiceLinks, :bool, 30
    optional :preemptionPolicy, :string, 31
    map :overhead, :string, :message, 32, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    repeated :topologySpreadConstraints, :message, 33, "k8s.io.api.core.v1.TopologySpreadConstraint"
    optional :setHostnameAsFQDN, :bool, 35
  end
  add_message "k8s.io.api.core.v1.PodStatus" do
    optional :phase, :string, 1
    repeated :conditions, :message, 2, "k8s.io.api.core.v1.PodCondition"
    optional :message, :string, 3
    optional :reason, :string, 4
    optional :nominatedNodeName, :string, 11
    optional :hostIP, :string, 5
    optional :podIP, :string, 6
    repeated :podIPs, :message, 12, "k8s.io.api.core.v1.PodIP"
    optional :startTime, :message, 7, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    repeated :initContainerStatuses, :message, 10, "k8s.io.api.core.v1.ContainerStatus"
    repeated :containerStatuses, :message, 8, "k8s.io.api.core.v1.ContainerStatus"
    optional :qosClass, :string, 9
    repeated :ephemeralContainerStatuses, :message, 13, "k8s.io.api.core.v1.ContainerStatus"
  end
  add_message "k8s.io.api.core.v1.PodStatusResult" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :status, :message, 2, "k8s.io.api.core.v1.PodStatus"
  end
  add_message "k8s.io.api.core.v1.PodTemplate" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :template, :message, 2, "k8s.io.api.core.v1.PodTemplateSpec"
  end
  add_message "k8s.io.api.core.v1.PodTemplateList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.PodTemplate"
  end
  add_message "k8s.io.api.core.v1.PodTemplateSpec" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.PodSpec"
  end
  add_message "k8s.io.api.core.v1.PortStatus" do
    optional :port, :int32, 1
    optional :protocol, :string, 2
    optional :error, :string, 3
  end
  add_message "k8s.io.api.core.v1.PortworxVolumeSource" do
    optional :volumeID, :string, 1
    optional :fsType, :string, 2
    optional :readOnly, :bool, 3
  end
  add_message "k8s.io.api.core.v1.Preconditions" do
    optional :uid, :string, 1
  end
  add_message "k8s.io.api.core.v1.PreferAvoidPodsEntry" do
    optional :podSignature, :message, 1, "k8s.io.api.core.v1.PodSignature"
    optional :evictionTime, :message, 2, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :reason, :string, 3
    optional :message, :string, 4
  end
  add_message "k8s.io.api.core.v1.PreferredSchedulingTerm" do
    optional :weight, :int32, 1
    optional :preference, :message, 2, "k8s.io.api.core.v1.NodeSelectorTerm"
  end
  add_message "k8s.io.api.core.v1.Probe" do
    optional :handler, :message, 1, "k8s.io.api.core.v1.Handler"
    optional :initialDelaySeconds, :int32, 2
    optional :timeoutSeconds, :int32, 3
    optional :periodSeconds, :int32, 4
    optional :successThreshold, :int32, 5
    optional :failureThreshold, :int32, 6
  end
  add_message "k8s.io.api.core.v1.ProjectedVolumeSource" do
    repeated :sources, :message, 1, "k8s.io.api.core.v1.VolumeProjection"
    optional :defaultMode, :int32, 2
  end
  add_message "k8s.io.api.core.v1.QuobyteVolumeSource" do
    optional :registry, :string, 1
    optional :volume, :string, 2
    optional :readOnly, :bool, 3
    optional :user, :string, 4
    optional :group, :string, 5
    optional :tenant, :string, 6
  end
  add_message "k8s.io.api.core.v1.RBDPersistentVolumeSource" do
    repeated :monitors, :string, 1
    optional :image, :string, 2
    optional :fsType, :string, 3
    optional :pool, :string, 4
    optional :user, :string, 5
    optional :keyring, :string, 6
    optional :secretRef, :message, 7, "k8s.io.api.core.v1.SecretReference"
    optional :readOnly, :bool, 8
  end
  add_message "k8s.io.api.core.v1.RBDVolumeSource" do
    repeated :monitors, :string, 1
    optional :image, :string, 2
    optional :fsType, :string, 3
    optional :pool, :string, 4
    optional :user, :string, 5
    optional :keyring, :string, 6
    optional :secretRef, :message, 7, "k8s.io.api.core.v1.LocalObjectReference"
    optional :readOnly, :bool, 8
  end
  add_message "k8s.io.api.core.v1.RangeAllocation" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :range, :string, 2
    optional :data, :bytes, 3
  end
  add_message "k8s.io.api.core.v1.ReplicationController" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.ReplicationControllerSpec"
    optional :status, :message, 3, "k8s.io.api.core.v1.ReplicationControllerStatus"
  end
  add_message "k8s.io.api.core.v1.ReplicationControllerCondition" do
    optional :type, :string, 1
    optional :status, :string, 2
    optional :lastTransitionTime, :message, 3, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
    optional :reason, :string, 4
    optional :message, :string, 5
  end
  add_message "k8s.io.api.core.v1.ReplicationControllerList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.ReplicationController"
  end
  add_message "k8s.io.api.core.v1.ReplicationControllerSpec" do
    optional :replicas, :int32, 1
    optional :minReadySeconds, :int32, 4
    map :selector, :string, :string, 2
    optional :template, :message, 3, "k8s.io.api.core.v1.PodTemplateSpec"
  end
  add_message "k8s.io.api.core.v1.ReplicationControllerStatus" do
    optional :replicas, :int32, 1
    optional :fullyLabeledReplicas, :int32, 2
    optional :readyReplicas, :int32, 4
    optional :availableReplicas, :int32, 5
    optional :observedGeneration, :int64, 3
    repeated :conditions, :message, 6, "k8s.io.api.core.v1.ReplicationControllerCondition"
  end
  add_message "k8s.io.api.core.v1.ResourceFieldSelector" do
    optional :containerName, :string, 1
    optional :resource, :string, 2
    optional :divisor, :message, 3, "k8s.io.apimachinery.pkg.api.resource.Quantity"
  end
  add_message "k8s.io.api.core.v1.ResourceQuota" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.ResourceQuotaSpec"
    optional :status, :message, 3, "k8s.io.api.core.v1.ResourceQuotaStatus"
  end
  add_message "k8s.io.api.core.v1.ResourceQuotaList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.ResourceQuota"
  end
  add_message "k8s.io.api.core.v1.ResourceQuotaSpec" do
    map :hard, :string, :message, 1, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    repeated :scopes, :string, 2
    optional :scopeSelector, :message, 3, "k8s.io.api.core.v1.ScopeSelector"
  end
  add_message "k8s.io.api.core.v1.ResourceQuotaStatus" do
    map :hard, :string, :message, 1, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    map :used, :string, :message, 2, "k8s.io.apimachinery.pkg.api.resource.Quantity"
  end
  add_message "k8s.io.api.core.v1.ResourceRequirements" do
    map :limits, :string, :message, 1, "k8s.io.apimachinery.pkg.api.resource.Quantity"
    map :requests, :string, :message, 2, "k8s.io.apimachinery.pkg.api.resource.Quantity"
  end
  add_message "k8s.io.api.core.v1.SELinuxOptions" do
    optional :user, :string, 1
    optional :role, :string, 2
    optional :type, :string, 3
    optional :level, :string, 4
  end
  add_message "k8s.io.api.core.v1.ScaleIOPersistentVolumeSource" do
    optional :gateway, :string, 1
    optional :system, :string, 2
    optional :secretRef, :message, 3, "k8s.io.api.core.v1.SecretReference"
    optional :sslEnabled, :bool, 4
    optional :protectionDomain, :string, 5
    optional :storagePool, :string, 6
    optional :storageMode, :string, 7
    optional :volumeName, :string, 8
    optional :fsType, :string, 9
    optional :readOnly, :bool, 10
  end
  add_message "k8s.io.api.core.v1.ScaleIOVolumeSource" do
    optional :gateway, :string, 1
    optional :system, :string, 2
    optional :secretRef, :message, 3, "k8s.io.api.core.v1.LocalObjectReference"
    optional :sslEnabled, :bool, 4
    optional :protectionDomain, :string, 5
    optional :storagePool, :string, 6
    optional :storageMode, :string, 7
    optional :volumeName, :string, 8
    optional :fsType, :string, 9
    optional :readOnly, :bool, 10
  end
  add_message "k8s.io.api.core.v1.ScopeSelector" do
    repeated :matchExpressions, :message, 1, "k8s.io.api.core.v1.ScopedResourceSelectorRequirement"
  end
  add_message "k8s.io.api.core.v1.ScopedResourceSelectorRequirement" do
    optional :scopeName, :string, 1
    optional :operator, :string, 2
    repeated :values, :string, 3
  end
  add_message "k8s.io.api.core.v1.SeccompProfile" do
    optional :type, :string, 1
    optional :localhostProfile, :string, 2
  end
  add_message "k8s.io.api.core.v1.Secret" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :immutable, :bool, 5
    map :data, :string, :bytes, 2
    map :stringData, :string, :string, 4
    optional :type, :string, 3
  end
  add_message "k8s.io.api.core.v1.SecretEnvSource" do
    optional :localObjectReference, :message, 1, "k8s.io.api.core.v1.LocalObjectReference"
    optional :optional, :bool, 2
  end
  add_message "k8s.io.api.core.v1.SecretKeySelector" do
    optional :localObjectReference, :message, 1, "k8s.io.api.core.v1.LocalObjectReference"
    optional :key, :string, 2
    optional :optional, :bool, 3
  end
  add_message "k8s.io.api.core.v1.SecretList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.Secret"
  end
  add_message "k8s.io.api.core.v1.SecretProjection" do
    optional :localObjectReference, :message, 1, "k8s.io.api.core.v1.LocalObjectReference"
    repeated :items, :message, 2, "k8s.io.api.core.v1.KeyToPath"
    optional :optional, :bool, 4
  end
  add_message "k8s.io.api.core.v1.SecretReference" do
    optional :name, :string, 1
    optional :namespace, :string, 2
  end
  add_message "k8s.io.api.core.v1.SecretVolumeSource" do
    optional :secretName, :string, 1
    repeated :items, :message, 2, "k8s.io.api.core.v1.KeyToPath"
    optional :defaultMode, :int32, 3
    optional :optional, :bool, 4
  end
  add_message "k8s.io.api.core.v1.SecurityContext" do
    optional :capabilities, :message, 1, "k8s.io.api.core.v1.Capabilities"
    optional :privileged, :bool, 2
    optional :seLinuxOptions, :message, 3, "k8s.io.api.core.v1.SELinuxOptions"
    optional :windowsOptions, :message, 10, "k8s.io.api.core.v1.WindowsSecurityContextOptions"
    optional :runAsUser, :int64, 4
    optional :runAsGroup, :int64, 8
    optional :runAsNonRoot, :bool, 5
    optional :readOnlyRootFilesystem, :bool, 6
    optional :allowPrivilegeEscalation, :bool, 7
    optional :procMount, :string, 9
    optional :seccompProfile, :message, 11, "k8s.io.api.core.v1.SeccompProfile"
  end
  add_message "k8s.io.api.core.v1.SerializedReference" do
    optional :reference, :message, 1, "k8s.io.api.core.v1.ObjectReference"
  end
  add_message "k8s.io.api.core.v1.Service" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    optional :spec, :message, 2, "k8s.io.api.core.v1.ServiceSpec"
    optional :status, :message, 3, "k8s.io.api.core.v1.ServiceStatus"
  end
  add_message "k8s.io.api.core.v1.ServiceAccount" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta"
    repeated :secrets, :message, 2, "k8s.io.api.core.v1.ObjectReference"
    repeated :imagePullSecrets, :message, 3, "k8s.io.api.core.v1.LocalObjectReference"
    optional :automountServiceAccountToken, :bool, 4
  end
  add_message "k8s.io.api.core.v1.ServiceAccountList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.ServiceAccount"
  end
  add_message "k8s.io.api.core.v1.ServiceAccountTokenProjection" do
    optional :audience, :string, 1
    optional :expirationSeconds, :int64, 2
    optional :path, :string, 3
  end
  add_message "k8s.io.api.core.v1.ServiceList" do
    optional :metadata, :message, 1, "k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta"
    repeated :items, :message, 2, "k8s.io.api.core.v1.Service"
  end
  add_message "k8s.io.api.core.v1.ServicePort" do
    optional :name, :string, 1
    optional :protocol, :string, 2
    optional :appProtocol, :string, 6
    optional :port, :int32, 3
    optional :targetPort, :message, 4, "k8s.io.apimachinery.pkg.util.intstr.IntOrString"
    optional :nodePort, :int32, 5
  end
  add_message "k8s.io.api.core.v1.ServiceProxyOptions" do
    optional :path, :string, 1
  end
  add_message "k8s.io.api.core.v1.ServiceSpec" do
    repeated :ports, :message, 1, "k8s.io.api.core.v1.ServicePort"
    map :selector, :string, :string, 2
    optional :clusterIP, :string, 3
    repeated :clusterIPs, :string, 18
    optional :type, :string, 4
    repeated :externalIPs, :string, 5
    optional :sessionAffinity, :string, 7
    optional :loadBalancerIP, :string, 8
    repeated :loadBalancerSourceRanges, :string, 9
    optional :externalName, :string, 10
    optional :externalTrafficPolicy, :string, 11
    optional :healthCheckNodePort, :int32, 12
    optional :publishNotReadyAddresses, :bool, 13
    optional :sessionAffinityConfig, :message, 14, "k8s.io.api.core.v1.SessionAffinityConfig"
    repeated :topologyKeys, :string, 16
    repeated :ipFamilies, :string, 19
    optional :ipFamilyPolicy, :string, 17
    optional :allocateLoadBalancerNodePorts, :bool, 20
  end
  add_message "k8s.io.api.core.v1.ServiceStatus" do
    optional :loadBalancer, :message, 1, "k8s.io.api.core.v1.LoadBalancerStatus"
    repeated :conditions, :message, 2, "k8s.io.apimachinery.pkg.apis.meta.v1.Condition"
  end
  add_message "k8s.io.api.core.v1.SessionAffinityConfig" do
    optional :clientIP, :message, 1, "k8s.io.api.core.v1.ClientIPConfig"
  end
  add_message "k8s.io.api.core.v1.StorageOSPersistentVolumeSource" do
    optional :volumeName, :string, 1
    optional :volumeNamespace, :string, 2
    optional :fsType, :string, 3
    optional :readOnly, :bool, 4
    optional :secretRef, :message, 5, "k8s.io.api.core.v1.ObjectReference"
  end
  add_message "k8s.io.api.core.v1.StorageOSVolumeSource" do
    optional :volumeName, :string, 1
    optional :volumeNamespace, :string, 2
    optional :fsType, :string, 3
    optional :readOnly, :bool, 4
    optional :secretRef, :message, 5, "k8s.io.api.core.v1.LocalObjectReference"
  end
  add_message "k8s.io.api.core.v1.Sysctl" do
    optional :name, :string, 1
    optional :value, :string, 2
  end
  add_message "k8s.io.api.core.v1.TCPSocketAction" do
    optional :port, :message, 1, "k8s.io.apimachinery.pkg.util.intstr.IntOrString"
    optional :host, :string, 2
  end
  add_message "k8s.io.api.core.v1.Taint" do
    optional :key, :string, 1
    optional :value, :string, 2
    optional :effect, :string, 3
    optional :timeAdded, :message, 4, "k8s.io.apimachinery.pkg.apis.meta.v1.Time"
  end
  add_message "k8s.io.api.core.v1.Toleration" do
    optional :key, :string, 1
    optional :operator, :string, 2
    optional :value, :string, 3
    optional :effect, :string, 4
    optional :tolerationSeconds, :int64, 5
  end
  add_message "k8s.io.api.core.v1.TopologySelectorLabelRequirement" do
    optional :key, :string, 1
    repeated :values, :string, 2
  end
  add_message "k8s.io.api.core.v1.TopologySelectorTerm" do
    repeated :matchLabelExpressions, :message, 1, "k8s.io.api.core.v1.TopologySelectorLabelRequirement"
  end
  add_message "k8s.io.api.core.v1.TopologySpreadConstraint" do
    optional :maxSkew, :int32, 1
    optional :topologyKey, :string, 2
    optional :whenUnsatisfiable, :string, 3
    optional :labelSelector, :message, 4, "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
  end
  add_message "k8s.io.api.core.v1.TypedLocalObjectReference" do
    optional :apiGroup, :string, 1
    optional :kind, :string, 2
    optional :name, :string, 3
  end
  add_message "k8s.io.api.core.v1.Volume" do
    optional :name, :string, 1
    optional :volumeSource, :message, 2, "k8s.io.api.core.v1.VolumeSource"
  end
  add_message "k8s.io.api.core.v1.VolumeDevice" do
    optional :name, :string, 1
    optional :devicePath, :string, 2
  end
  add_message "k8s.io.api.core.v1.VolumeMount" do
    optional :name, :string, 1
    optional :readOnly, :bool, 2
    optional :mountPath, :string, 3
    optional :subPath, :string, 4
    optional :mountPropagation, :string, 5
    optional :subPathExpr, :string, 6
  end
  add_message "k8s.io.api.core.v1.VolumeNodeAffinity" do
    optional :required, :message, 1, "k8s.io.api.core.v1.NodeSelector"
  end
  add_message "k8s.io.api.core.v1.VolumeProjection" do
    optional :secret, :message, 1, "k8s.io.api.core.v1.SecretProjection"
    optional :downwardAPI, :message, 2, "k8s.io.api.core.v1.DownwardAPIProjection"
    optional :configMap, :message, 3, "k8s.io.api.core.v1.ConfigMapProjection"
    optional :serviceAccountToken, :message, 4, "k8s.io.api.core.v1.ServiceAccountTokenProjection"
  end
  add_message "k8s.io.api.core.v1.VolumeSource" do
    optional :hostPath, :message, 1, "k8s.io.api.core.v1.HostPathVolumeSource"
    optional :emptyDir, :message, 2, "k8s.io.api.core.v1.EmptyDirVolumeSource"
    optional :gcePersistentDisk, :message, 3, "k8s.io.api.core.v1.GCEPersistentDiskVolumeSource"
    optional :awsElasticBlockStore, :message, 4, "k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource"
    optional :gitRepo, :message, 5, "k8s.io.api.core.v1.GitRepoVolumeSource"
    optional :secret, :message, 6, "k8s.io.api.core.v1.SecretVolumeSource"
    optional :nfs, :message, 7, "k8s.io.api.core.v1.NFSVolumeSource"
    optional :iscsi, :message, 8, "k8s.io.api.core.v1.ISCSIVolumeSource"
    optional :glusterfs, :message, 9, "k8s.io.api.core.v1.GlusterfsVolumeSource"
    optional :persistentVolumeClaim, :message, 10, "k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource"
    optional :rbd, :message, 11, "k8s.io.api.core.v1.RBDVolumeSource"
    optional :flexVolume, :message, 12, "k8s.io.api.core.v1.FlexVolumeSource"
    optional :cinder, :message, 13, "k8s.io.api.core.v1.CinderVolumeSource"
    optional :cephfs, :message, 14, "k8s.io.api.core.v1.CephFSVolumeSource"
    optional :flocker, :message, 15, "k8s.io.api.core.v1.FlockerVolumeSource"
    optional :downwardAPI, :message, 16, "k8s.io.api.core.v1.DownwardAPIVolumeSource"
    optional :fc, :message, 17, "k8s.io.api.core.v1.FCVolumeSource"
    optional :azureFile, :message, 18, "k8s.io.api.core.v1.AzureFileVolumeSource"
    optional :configMap, :message, 19, "k8s.io.api.core.v1.ConfigMapVolumeSource"
    optional :vsphereVolume, :message, 20, "k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource"
    optional :quobyte, :message, 21, "k8s.io.api.core.v1.QuobyteVolumeSource"
    optional :azureDisk, :message, 22, "k8s.io.api.core.v1.AzureDiskVolumeSource"
    optional :photonPersistentDisk, :message, 23, "k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource"
    optional :projected, :message, 26, "k8s.io.api.core.v1.ProjectedVolumeSource"
    optional :portworxVolume, :message, 24, "k8s.io.api.core.v1.PortworxVolumeSource"
    optional :scaleIO, :message, 25, "k8s.io.api.core.v1.ScaleIOVolumeSource"
    optional :storageos, :message, 27, "k8s.io.api.core.v1.StorageOSVolumeSource"
    optional :csi, :message, 28, "k8s.io.api.core.v1.CSIVolumeSource"
    optional :ephemeral, :message, 29, "k8s.io.api.core.v1.EphemeralVolumeSource"
  end
  add_message "k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource" do
    optional :volumePath, :string, 1
    optional :fsType, :string, 2
    optional :storagePolicyName, :string, 3
    optional :storagePolicyID, :string, 4
  end
  add_message "k8s.io.api.core.v1.WeightedPodAffinityTerm" do
    optional :weight, :int32, 1
    optional :podAffinityTerm, :message, 2, "k8s.io.api.core.v1.PodAffinityTerm"
  end
  add_message "k8s.io.api.core.v1.WindowsSecurityContextOptions" do
    optional :gmsaCredentialSpecName, :string, 1
    optional :gmsaCredentialSpec, :string, 2
    optional :runAsUserName, :string, 3
  end
end

module K8s
  module Io
    module Api
      module Core
        module V1
          AWSElasticBlockStoreVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource").msgclass
          Affinity = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Affinity").msgclass
          AttachedVolume = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.AttachedVolume").msgclass
          AvoidPods = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.AvoidPods").msgclass
          AzureDiskVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.AzureDiskVolumeSource").msgclass
          AzureFilePersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.AzureFilePersistentVolumeSource").msgclass
          AzureFileVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.AzureFileVolumeSource").msgclass
          Binding = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Binding").msgclass
          CSIPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.CSIPersistentVolumeSource").msgclass
          CSIVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.CSIVolumeSource").msgclass
          Capabilities = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Capabilities").msgclass
          CephFSPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.CephFSPersistentVolumeSource").msgclass
          CephFSVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.CephFSVolumeSource").msgclass
          CinderPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.CinderPersistentVolumeSource").msgclass
          CinderVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.CinderVolumeSource").msgclass
          ClientIPConfig = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ClientIPConfig").msgclass
          ComponentCondition = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ComponentCondition").msgclass
          ComponentStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ComponentStatus").msgclass
          ComponentStatusList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ComponentStatusList").msgclass
          ConfigMap = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ConfigMap").msgclass
          ConfigMapEnvSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ConfigMapEnvSource").msgclass
          ConfigMapKeySelector = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ConfigMapKeySelector").msgclass
          ConfigMapList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ConfigMapList").msgclass
          ConfigMapNodeConfigSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ConfigMapNodeConfigSource").msgclass
          ConfigMapProjection = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ConfigMapProjection").msgclass
          ConfigMapVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ConfigMapVolumeSource").msgclass
          Container = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Container").msgclass
          ContainerImage = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ContainerImage").msgclass
          ContainerPort = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ContainerPort").msgclass
          ContainerState = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ContainerState").msgclass
          ContainerStateRunning = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ContainerStateRunning").msgclass
          ContainerStateTerminated = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ContainerStateTerminated").msgclass
          ContainerStateWaiting = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ContainerStateWaiting").msgclass
          ContainerStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ContainerStatus").msgclass
          DaemonEndpoint = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.DaemonEndpoint").msgclass
          DownwardAPIProjection = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.DownwardAPIProjection").msgclass
          DownwardAPIVolumeFile = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.DownwardAPIVolumeFile").msgclass
          DownwardAPIVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.DownwardAPIVolumeSource").msgclass
          EmptyDirVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EmptyDirVolumeSource").msgclass
          EndpointAddress = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EndpointAddress").msgclass
          EndpointPort = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EndpointPort").msgclass
          EndpointSubset = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EndpointSubset").msgclass
          Endpoints = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Endpoints").msgclass
          EndpointsList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EndpointsList").msgclass
          EnvFromSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EnvFromSource").msgclass
          EnvVar = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EnvVar").msgclass
          EnvVarSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EnvVarSource").msgclass
          EphemeralContainer = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EphemeralContainer").msgclass
          EphemeralContainerCommon = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EphemeralContainerCommon").msgclass
          EphemeralContainers = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EphemeralContainers").msgclass
          EphemeralVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EphemeralVolumeSource").msgclass
          Event = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Event").msgclass
          EventList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EventList").msgclass
          EventSeries = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EventSeries").msgclass
          EventSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.EventSource").msgclass
          ExecAction = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ExecAction").msgclass
          FCVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.FCVolumeSource").msgclass
          FlexPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.FlexPersistentVolumeSource").msgclass
          FlexVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.FlexVolumeSource").msgclass
          FlockerVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.FlockerVolumeSource").msgclass
          GCEPersistentDiskVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.GCEPersistentDiskVolumeSource").msgclass
          GitRepoVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.GitRepoVolumeSource").msgclass
          GlusterfsPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.GlusterfsPersistentVolumeSource").msgclass
          GlusterfsVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.GlusterfsVolumeSource").msgclass
          HTTPGetAction = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.HTTPGetAction").msgclass
          HTTPHeader = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.HTTPHeader").msgclass
          Handler = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Handler").msgclass
          HostAlias = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.HostAlias").msgclass
          HostPathVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.HostPathVolumeSource").msgclass
          ISCSIPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ISCSIPersistentVolumeSource").msgclass
          ISCSIVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ISCSIVolumeSource").msgclass
          KeyToPath = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.KeyToPath").msgclass
          Lifecycle = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Lifecycle").msgclass
          LimitRange = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.LimitRange").msgclass
          LimitRangeItem = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.LimitRangeItem").msgclass
          LimitRangeList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.LimitRangeList").msgclass
          LimitRangeSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.LimitRangeSpec").msgclass
          List = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.List").msgclass
          LoadBalancerIngress = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.LoadBalancerIngress").msgclass
          LoadBalancerStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.LoadBalancerStatus").msgclass
          LocalObjectReference = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.LocalObjectReference").msgclass
          LocalVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.LocalVolumeSource").msgclass
          NFSVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NFSVolumeSource").msgclass
          Namespace = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Namespace").msgclass
          NamespaceCondition = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NamespaceCondition").msgclass
          NamespaceList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NamespaceList").msgclass
          NamespaceSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NamespaceSpec").msgclass
          NamespaceStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NamespaceStatus").msgclass
          Node = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Node").msgclass
          NodeAddress = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeAddress").msgclass
          NodeAffinity = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeAffinity").msgclass
          NodeCondition = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeCondition").msgclass
          NodeConfigSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeConfigSource").msgclass
          NodeConfigStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeConfigStatus").msgclass
          NodeDaemonEndpoints = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeDaemonEndpoints").msgclass
          NodeList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeList").msgclass
          NodeProxyOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeProxyOptions").msgclass
          NodeResources = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeResources").msgclass
          NodeSelector = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeSelector").msgclass
          NodeSelectorRequirement = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeSelectorRequirement").msgclass
          NodeSelectorTerm = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeSelectorTerm").msgclass
          NodeSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeSpec").msgclass
          NodeStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeStatus").msgclass
          NodeSystemInfo = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.NodeSystemInfo").msgclass
          ObjectFieldSelector = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ObjectFieldSelector").msgclass
          ObjectReference = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ObjectReference").msgclass
          PersistentVolume = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolume").msgclass
          PersistentVolumeClaim = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeClaim").msgclass
          PersistentVolumeClaimCondition = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeClaimCondition").msgclass
          PersistentVolumeClaimList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeClaimList").msgclass
          PersistentVolumeClaimSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeClaimSpec").msgclass
          PersistentVolumeClaimStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeClaimStatus").msgclass
          PersistentVolumeClaimTemplate = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeClaimTemplate").msgclass
          PersistentVolumeClaimVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource").msgclass
          PersistentVolumeList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeList").msgclass
          PersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeSource").msgclass
          PersistentVolumeSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeSpec").msgclass
          PersistentVolumeStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PersistentVolumeStatus").msgclass
          PhotonPersistentDiskVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource").msgclass
          Pod = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Pod").msgclass
          PodAffinity = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodAffinity").msgclass
          PodAffinityTerm = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodAffinityTerm").msgclass
          PodAntiAffinity = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodAntiAffinity").msgclass
          PodAttachOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodAttachOptions").msgclass
          PodCondition = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodCondition").msgclass
          PodDNSConfig = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodDNSConfig").msgclass
          PodDNSConfigOption = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodDNSConfigOption").msgclass
          PodExecOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodExecOptions").msgclass
          PodIP = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodIP").msgclass
          PodList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodList").msgclass
          PodLogOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodLogOptions").msgclass
          PodPortForwardOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodPortForwardOptions").msgclass
          PodProxyOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodProxyOptions").msgclass
          PodReadinessGate = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodReadinessGate").msgclass
          PodSecurityContext = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodSecurityContext").msgclass
          PodSignature = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodSignature").msgclass
          PodSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodSpec").msgclass
          PodStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodStatus").msgclass
          PodStatusResult = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodStatusResult").msgclass
          PodTemplate = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodTemplate").msgclass
          PodTemplateList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodTemplateList").msgclass
          PodTemplateSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PodTemplateSpec").msgclass
          PortStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PortStatus").msgclass
          PortworxVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PortworxVolumeSource").msgclass
          Preconditions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Preconditions").msgclass
          PreferAvoidPodsEntry = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PreferAvoidPodsEntry").msgclass
          PreferredSchedulingTerm = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.PreferredSchedulingTerm").msgclass
          Probe = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Probe").msgclass
          ProjectedVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ProjectedVolumeSource").msgclass
          QuobyteVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.QuobyteVolumeSource").msgclass
          RBDPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.RBDPersistentVolumeSource").msgclass
          RBDVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.RBDVolumeSource").msgclass
          RangeAllocation = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.RangeAllocation").msgclass
          ReplicationController = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ReplicationController").msgclass
          ReplicationControllerCondition = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ReplicationControllerCondition").msgclass
          ReplicationControllerList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ReplicationControllerList").msgclass
          ReplicationControllerSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ReplicationControllerSpec").msgclass
          ReplicationControllerStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ReplicationControllerStatus").msgclass
          ResourceFieldSelector = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ResourceFieldSelector").msgclass
          ResourceQuota = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ResourceQuota").msgclass
          ResourceQuotaList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ResourceQuotaList").msgclass
          ResourceQuotaSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ResourceQuotaSpec").msgclass
          ResourceQuotaStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ResourceQuotaStatus").msgclass
          ResourceRequirements = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ResourceRequirements").msgclass
          SELinuxOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SELinuxOptions").msgclass
          ScaleIOPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ScaleIOPersistentVolumeSource").msgclass
          ScaleIOVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ScaleIOVolumeSource").msgclass
          ScopeSelector = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ScopeSelector").msgclass
          ScopedResourceSelectorRequirement = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ScopedResourceSelectorRequirement").msgclass
          SeccompProfile = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SeccompProfile").msgclass
          Secret = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Secret").msgclass
          SecretEnvSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SecretEnvSource").msgclass
          SecretKeySelector = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SecretKeySelector").msgclass
          SecretList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SecretList").msgclass
          SecretProjection = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SecretProjection").msgclass
          SecretReference = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SecretReference").msgclass
          SecretVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SecretVolumeSource").msgclass
          SecurityContext = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SecurityContext").msgclass
          SerializedReference = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SerializedReference").msgclass
          Service = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Service").msgclass
          ServiceAccount = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ServiceAccount").msgclass
          ServiceAccountList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ServiceAccountList").msgclass
          ServiceAccountTokenProjection = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ServiceAccountTokenProjection").msgclass
          ServiceList = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ServiceList").msgclass
          ServicePort = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ServicePort").msgclass
          ServiceProxyOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ServiceProxyOptions").msgclass
          ServiceSpec = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ServiceSpec").msgclass
          ServiceStatus = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.ServiceStatus").msgclass
          SessionAffinityConfig = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.SessionAffinityConfig").msgclass
          StorageOSPersistentVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.StorageOSPersistentVolumeSource").msgclass
          StorageOSVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.StorageOSVolumeSource").msgclass
          Sysctl = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Sysctl").msgclass
          TCPSocketAction = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.TCPSocketAction").msgclass
          Taint = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Taint").msgclass
          Toleration = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Toleration").msgclass
          TopologySelectorLabelRequirement = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.TopologySelectorLabelRequirement").msgclass
          TopologySelectorTerm = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.TopologySelectorTerm").msgclass
          TopologySpreadConstraint = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.TopologySpreadConstraint").msgclass
          TypedLocalObjectReference = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.TypedLocalObjectReference").msgclass
          Volume = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.Volume").msgclass
          VolumeDevice = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.VolumeDevice").msgclass
          VolumeMount = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.VolumeMount").msgclass
          VolumeNodeAffinity = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.VolumeNodeAffinity").msgclass
          VolumeProjection = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.VolumeProjection").msgclass
          VolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.VolumeSource").msgclass
          VsphereVirtualDiskVolumeSource = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource").msgclass
          WeightedPodAffinityTerm = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.WeightedPodAffinityTerm").msgclass
          WindowsSecurityContextOptions = Google::Protobuf::DescriptorPool.generated_pool.lookup("k8s.io.api.core.v1.WindowsSecurityContextOptions").msgclass
        end
      end
    end
  end
end
